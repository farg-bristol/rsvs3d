function [] = RSVS3D_interface()
    %FUNCTIONLIST allows local functions to be used globally once it has
    %been used.
    
    funcHandles=localfunctions;
    funcDir=[cd,'\Automated_Function_Directory'];
    HeaderActivation(funcHandles,funcDir)
    
    include_Utilities
end


%% Parameter reading and parsing

% Read default parameters
function [defaultparam]=RSVS3D_DefaultParam(pathRSVS, defaultName)

    if~exist('pathRSVS', 'var'); pathRSVS = '.';end
    if~exist('defaultName', 'var')
        defaultName = './defaultconfigRSVS3D.json';
    end

    if isunix()
       fileExt = ''; 
    else
       fileExt = '.exe';
    end
    
    pathDefaultConf = [pathRSVS, filesep, 'RSVS3D', fileExt];
    command =[pathDefaultConf, ' --noexec=', defaultName];
    [s,o] = systemnomatlab(command);
    if s
        errorstruct.identifier='rsvs3D:param:default';
        errorstruct.message=['Failure to process command "',command,'"'];
        error(errorstruct)
    end
    [defaultparam]=RSVS3D_ReadParam(defaultName);
end

function [paramOut]=RSVS3D_ReadParam(fileIn)
    
    fid = fopen(fileIn, 'r');
    string = ''; 
    while ~feof(fid)
        string = [string, squeeze(fgetl(fid))];
    end
    fclose(fid);
    paramOut = jsondecode(string);
    [paramOut.structdat]=GetStructureData(paramOut);

end

% Write new parameter files
function [success]=RSVS3D_WriteParam(paramIn, fileOut)
    
    if(numel(ExtractVariables({'inputpoints'},paramIn))<2)
        paramIn.grid.voronoi=rmfield(paramIn.grid.voronoi,'inputpoints');
    end
    
    fid = fopen(fileOut ,'w');
    strJson = jsonencode(rmfield(paramIn,'structdat'));
    success=fprintf(fid, '%s', strJson);
    fclose(fid);

end
% Handle a few standard modifications

%% Callers for the RSVS3D

% Caller to handle correcting the file structure
% This caller sets the outputs to a specific directory

% Caller to generate meshes
% Achieved by calling RSVS3D with 0 steps and no exports

% Caller to run export
% Run in full "loading" mode and 0 steps

% caller to run RSVS process
% Full loading 

% Base caller
function [outRSVS3D]=RSVS3D_Caller(param3D, configOutput)
    % RSVS3D_CALLER Call the RSVS 3D executable with a predefined config.
    %  PARAM3D: The set of 3D-RSVS parameters to be called
    %  CONFIGOUTPUT: A structure configuring calling options for the RSVS3D
    %    The default structure can be built using RSVS3D_CALLCONFIG
    
    if ~exist('configOutput','var'); configOutput = RSVS3D_CallConfig();end
    
    % Write parameter file
    writeStatus=RSVS3D_WriteParam(param3D, configOutput.paramOut);
    
    if writeStatus<=0 % Not enough characters written
        errstruct.identifier = 'rsvs3D:caller:writeparam';
        errstruct.message = 'Parameter file was not correctly written';
        error(errstruct)
    end
    
    % Call RSVS
    [cmd]=RSVS3D_Config2Cmd(configOutput);
    [status, output]=systemnomatlab(cmd);
   
    if status~=0 % Program should end with status==0
        errstruct.identifier = 'rsvs3D:caller:execution';
        fmtMessage = ['Exit status of "RSVS3D" was not 0 (%i); \n', ...
            ' - command: \n%s\n - output:\n%s\n'];
        errstruct.message = sprintf(fmtMessage, status, cmd, output);
        error(errstruct)
    end
    
    % Check results for output folder
    [outRSVS3D, errorstatus] = RSVS3D_ProcessCall(output);
    if errorstatus
        warning('Errors detected while processic the RSVS3D output.')
    end
end

function [defaultConfig]=RSVS3D_CallConfig()
    % Path to the executable
    defaultConfig.executablePath = 'RSVS3D';
    % Execution path, path from which this command should be executed
    defaultConfig.executionPath = '.';
    % Commands to prepend and post after the RSVS3D call
    defaultConfig.preCmd = '';
    defaultConfig.postCmd = '';
    % unique temp file
    if ~exist('temp','dir'), mkdir([cd,filesep,'temp']);end
    defaultConfig.paramOut = [tempname([cd,filesep,'temp']),'_3dparam.json'];
    defaultConfig.deleteParam = false;
    
end

function [cmd]=RSVS3D_Config2Cmd(config)
    % Builds the command from the config structure
    % structure generated by "RSVS3D_CallConfig"
    cmd = config.preCmd;
    if cmd; cmd = [cmd, ' && '];end
    cmd = [cmd, 'cd ', config.executionPath, ' && '];
    cmd = [cmd, config.executablePath, ' -l "', config.paramOut,'"'];
end

function [outRSVS3D, errorstatus] = RSVS3D_ProcessCall(charOut)
    % postprocess a call to RSVS3D
    
    outRSVS3D.char = regexp(charOut,'\n','split');
    errorstatus = 0;
    % Find errors
    errorStrings = {'error', 'unusual'};
    posError = RSVS3D_ProcessFindLines(outRSVS3D.char, errorStrings);
    errorstatus = numel(posError);
    % Find convergence
    convString = 'conv: ';
    posConv = RSVS3D_ProcessFindLines(outRSVS3D.char, convString);
    convstruct = repmat(RSVS3D_convstruct(),[1 0]);
    for i = posConv
        [convstruct(i)]=RSVS3D_ProcessConvergence(outRSVS3D.char{i},...
            convString);
    end
    outRSVS3D.conv = convstruct;
    % Find output directory
    dirString = 'Output folder:'; 
    posDir = RSVS3D_ProcessFindLines(outRSVS3D.char, dirString);
    if numel(posDir)>1
        warning('More than one folder output detected')
    end
    outRSVS3D.folder=RSVS3D_ProcessCallFolder(outRSVS3D.char{posDir(1)}, ...
        dirString);
end

function folder=RSVS3D_ProcessCallFolder(line, dirString)
    dirCells = regexp(squeeze(line), dirString, 'split');
    if (numel(dirCells)<1)
       warning('Output processing failed, returning multiple output folders.');
    else if 
        error('Output processing failed, no output folder found');
    end
    folder=dirCells{1};
end

function convstruct = RSVS3D_convstruct()
    convstruct.volume = 0;
    convstruct.velocity = 0;
end

function [convstruct]=RSVS3D_ProcessConvergence(line, convString)
    convstruct = RSVS3D_convstruct();
    
    fmtString = [convString, '(vol) %f (vel) %f'];
    posMatch = regexp(line, convString);
    [out, nOut, err] = sscanf(line(posMatch(1):end), fmtString);
    
    if nOut~=2
        error(err)
    end
    convstruct.volume = out(1);
    convstruct.velocity = out(2);
end

function [pos]=RSVS3D_ProcessFindLines(charAll, pattern)
    func = @(charAll, pat) find(~(cellfun(@isempty,regexp(charAll, pat))));
    D = size(charAll);
    pos = [];
    if iscell(pattern)
        for i = numel(pattern)
            posTemp = func(charAll, pattern{i});
            pos = [pos, posTemp];
        end
    else
        pos = func(charAll, pattern);
    end
    
end

%% callers for SU2






















